## Part 1. Готовый докер

 * Docker pull, а так же docker images:

 ![docker_pull](pictu/1.2.png)

 * Запусти докер-образ через docker run -d + docker ps:

 ![docker_pull](pictu/3.4.png)

 -d - запуск контейнера в фоновом режиме

 * Посмотри информацию о контейнере через docker inspect + ip контейнера:

 ![docker_pull](pictu/5.id.png)

 * помести в отчёт размер контейнера:

 ![docker_pull](pictu/5.size.png)

 * помести в отчёт список замапленных портов:

 ![docker_pull](pictu/5.ports.png)

 * Останови докер образ через docker stop + docker ps:

 ![docker_pull](pictu/6.7.png)

 * Запусти докер с портами 80 и 443 в контейнере:

 ![docker_pull](pictu/8.png)

  Порт 80: Это стандартный порт для протокола HTTP который используется для передачи веб-страниц.

  Порт 443: Это стандартный порт для протокола HTTPS, который является безопасной версией HTTP.

 * Проверь, что в браузере по localhost:80 доступна страница nginx :

 ![docker_pull](pictu/9.png)

 * Перезапусти докер контейнер через docker restart:

 ![docker_pull](pictu/10.png)


## Part 2. Операции с контейнером

 * Прочитай конфигурационный файл nginx.conf :

 ![docker_pull](pictu/11.png)

 * Создаем локальный файл nginx.conf,  так же  настраиваем  в нем по пути /status выдачу страницы статуса сервера:

 ![docker_pull](pictu/13.png)

 * Скопируй созданный файл nginx.conf внутрь докер-образа, так же перезапусти nginx внутри докер-образа :

  ![docker_pull](pictu/12.png)

 * Проверь, что по адресу localhost:80/status отдается страничка со статусом сервера nginx:

 ![localhost2](pictu/14.png)

 * Экспортируй контейнер и потом останови его :
   
 ![export](pictu/15.png)

 * Удали образ через docker rmi:
   
  ![delete](pictu/16.png)

  флаг -f означает "force" (принудительно). Этот флаг используется для принудительного удаления образа

 * Удали остановленный контейнер :

  ![delete](pictu/16.png)

 * Импортируй контейнер обратно через команду import:

  ![import](pictu/17.png)

 docker import  создает новый образ Docker из файла tar, который содержит файловую систему контейнера. 

 -c используется для добавления Dockerfile-инструкций к создаваемому образу

 CMD ["nginx", "-g", "daemon off;"] устанавливает команду по умолчанию, которая будет выполняться при запуске контейнера. команда nginx -g daemon off; запускает Nginx в режиме "daemon off", что означает, что Nginx будет работать в переднем плане


 * Запусти импортированный контейнер:

  ![run](pictu/18.png)


 * по адресу localhost:80/status отдается страничка со статусом сервера nginx:

  ![localhost](pictu/19.png)

  ## Part 3. Мини веб-сервер

 FastCGI - ротокол для взаимодействия между веб-сервером и внешним программным обеспечением. 
 spawn-fcgi — это инструмент для управления процессами FastCGI. Он позволяет запускать FastCGI приложения и управлять их жизненным циклом

 * Запусти написанный мини-сервер через spawn-fcgi на порту 8080:

  ![localhost](pictu/20.png)
  

* Напиши nginx.conf, который проксирyeт все запросы с 81 порта на 127.0.0.1:8080:

  ![conf](pictu/25.png)

  повторяем шаги из 1 части :

  docker pull nginx - выкачиваем опять докер-образ

  docker run  - запускаем контейнер

  docker cp  -копируем в него из локальной машины файл конфигурации, затем и код

  docker exec - подключаемся к  крнтейнеру

  ![conf](pictu/21.png)

  Компилируем и запускаем сервер - spawn-fcgi
  перезапуск nginx на контейнере - nginx -s reload:

  ![conf](pictu/22.png)

 * Проверь, что в браузере по localhost:81 отдается написанная тобой страничка:

  ![conf](pictu/23.png)

 * Положи файл nginx.conf по пути ./nginx/nginx.conf :

  ![conf](pictu/24.png)

  ## Part 4. Свой докер

 * Напиши свой докер-образ, который:

 1) собирает исходники мини сервера на FastCgi из Части 3;

 2) запускает его на 8080 порту;

 3) копирует внутрь образа написанный ./nginx/nginx.conf;

 4) запускает nginx.

  ![conf](pictu/26.png)

  Скрипт  компилирует и запускает server.c  nginx:

  ![conf](pictu/27.png)

 * Cобери написанный докер-образ через docker build:

  ![alt text](pictu/28.png)

  -t позволяeт задать имя и тег образа

 * Проверь через docker images, что все собралось корректно:

  ![conf](pictu/29.png)

 * Запусти собранный докер-образ с маппингом 81 порта на 80 :

  ![conf](pictu/30.png)

  -d - запускает контейнер в фоновом режимe

  -v  - используется для между хостовой системой и контейнером. -v позволяет указать путь на хосте и соответствующий путь в контейнере
  
 * Проверь, что по localhost:80 доступна страничка написанного мини сервера:

  ![conf](pictu/31.png)

 * Допиши в ./nginx/nginx.conf проксирование странички /status:

  ![conf](pictu/32.png)

 * Перезапусти докер-образ + по localhost:80/status отдается страничка со статусом nginx:

  ![conf](pictu/33.png)

  ## Part 5. Dockle

  dockle — это инструмент для аудита безопасности Docker-образов. Он помогает обнаружить и исправить проблемы с безопасностью в Docker-образах перед их развертыванием.

 *  Просканируй образ из предыдущего задания :

  ![conf](pictu/34.png)

  ![conf](pictu/35.png)

  - DKL-DI-0005 - Кэш не очищаeтся

  - CIS-DI-0001 - cоздайте и используйте непривилегированного пользователя для запуска приложений в контейнере. Это снизит риски безопасности.

  - CIS-DI-0010 - dockle необходимо запускать с дополнительными флагами.

  - CIS-DI-0005 - Установите переменную окружения DOCKER_CONTENT_TRUST=1 перед выполнением команд docker pull или docker build. Это обеспечит проверку подлинности образов.

  - CIS-DI-0008 - В образе присутствуют файлы с установленными битами setuid и setgid. настроить права пользователей для работы с файлами по списку, разрешить всем запускать скрипт и исполняемые файлы

  - CIS-DI-0006 - Добавьте инструкцию HEALTHCHECK в Dockerfile для мониторинга состояния контейнера

  * Исправь образ так, чтобы не было ошибок:

   ![conf](pictu/366.png)

  - export DOCKER_CONTENT_TRUST=1 перед build'ом необходимо выполнить команду, чтобы убрать ошибку CIS-DI-0005. Потом билдим заново

  Проверяем:

  ![conf](pictu/36.png)

  ## Part 6. Базовый Docker Compose

  * Напиши файл docker-compose.yml:

  ![conf](pictu/52.png)

  * Подними докер-контейнер с nginx, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера:

  ![conf](pictu/51.png)

 * Собери и запусти проект с помощью команд docker-compose build и docker-compose up:
   
  ![conf](pictu/49.png)

  ![conf](pictu/50.png)

 * Проверь, что в браузере по localhost:80 отдается написанная тобой страничка:

   ![conf](pictu/53.png)